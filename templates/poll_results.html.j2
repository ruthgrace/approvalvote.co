{% extends "base.html.j2" %}

{% block content %}
<div class="space-y-4">
  <h1 class="text-3xl font-medium">{{title}}</h1>
  <p class="text-lg text-gray-500">{{description}}</p>
  <p class="text-lg">Poll results: {{winners}}</p>
  <div class="container mx-auto px-4">
    <div style="display: flex; justify-content: space-around; gap-20px;">
      <div style="flex: 1;">
        <h2 class="text-2xl font-bold mb-4">Votes</h2>
        <p>Here is an animated visualization of the multi-winner approval voting process. Watch as winners are selected and excess votes are redistributed in each round.</p>
        
        <!-- Animation controls -->
        <div class="flex gap-4 mb-4 items-center">
          <button id="playBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
            Play Animation
          </button>
          <button id="resetBtn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
            Reset
          </button>
          <button id="prevBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            ← Previous
          </button>
          <button id="nextBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            Next →
          </button>
          <span id="roundLabel" class="font-medium text-gray-700 ml-4">Round 1</span>
        </div>
        
        <div id="chart"></div>
        
        <!-- Round information display -->
        <div id="roundInfo" class="mt-4 p-4 bg-gray-50 rounded-lg">
          <div id="roundDescription" class="text-gray-700"></div>
        </div>
      </div>
    </div>
  </div>
  <hr />

  <h2 class="text-2xl font-medium">Did you have a different preferred result?</h2>
  <div class="bg-gray-50 rounded-3xl p-8 border border-gray-300 space-y-4">
    <p>You can see how many more votes the winners got than your preferred result. What was your preferred result?</p>
    <form hx-post="/resultsubmit" hx-target="#resultresponse" hx-swap="innerHTML">
      <input type="hidden" name="poll_id" value="{{ poll_id }}" />
      <input type="hidden" name="seats" value="{{ seats }}" />
      {% for id, candidate in candidates.items() %}
      <label>
        <input type="checkbox" name="poll_option" value="{{id}}|{{candidate}}" /> {{candidate}}
      </label>
      <br />
      {% endfor %}
    </div>
    <button type="resultsubmit" class="btn-primary">See how close your preferred candidates were to winning</button>
  </form>
  <div id="resultresponse"></div>
  
  <div class="mt-8">
    <a href="{{ url_for('download_votes_csv', poll_id=poll_id) }}" class="text-blue-600 border border-blue-600 hover:bg-blue-50 font-medium px-6 py-4 rounded-full transition duration-150 ease-in-out inline-block">Download votes</a>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ url_for('static', filename='js/chartStyles.js') }}"></script>
<script>
  // Parse data from Jinja
  const candidates = {{ candidates|tojson }};
  const excessRounds = {{ excess_rounds|tojson }};
  const seats = {{ seats }};
  
  // Set dimensions
  const margin = {top: 20, right: 20, bottom: 80, left: 60};
  const width = 800 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;
  const totalHeight = height + margin.top + margin.bottom;
  
  // Animation state
  let currentRound = 0;
  let currentPhase = 'initial'; // 'initial', 'winner', 'remove_excess', 'remove_ballots', 'add_excess'
  let isPlaying = false;
  let animationTimer = null;
  
  // Store winner thresholds (the votes they retain after winning)
  const winnerThresholds = {};
  
  // Get all candidate IDs
  const allCandidateIds = Object.keys(candidates).map(id => parseInt(id));
  
  // Prepare data for each round
  function prepareRoundData(roundIndex, showRemovedBallots = false) {
    if (roundIndex >= excessRounds.length) return null;
    
    const round = excessRounds[roundIndex];
    const voteCounts = {};
    
    // Initialize all candidates with 0
    allCandidateIds.forEach(id => {
      voteCounts[id] = 0;
    });
    
    if (showRemovedBallots && roundIndex > 0) {
      // Show the state after removing winner's ballots but before adding excess
      // This shows what happens when we remove all ballots containing the previous winner
      const prevRound = excessRounds[roundIndex - 1];
      
      // Get ballots that DON'T contain the previous winner
      if (prevRound.ballot_counts) {
        Object.entries(prevRound.ballot_counts).forEach(([ballotStr, count]) => {
          const ballot = JSON.parse(ballotStr);
          // Only count ballots that don't include the previous winner
          if (!ballot.includes(prevRound.winner)) {
            ballot.forEach(candId => {
              if (voteCounts[parseInt(candId)] !== undefined) {
                voteCounts[parseInt(candId)] += count;
              }
            });
          }
        });
      }
    } else {
      // Normal calculation
      // Calculate votes from ballot_counts (which has the redistributed votes)
      if (round.ballot_counts) {
        Object.entries(round.ballot_counts).forEach(([ballotStr, count]) => {
          // Parse the ballot string (it's a stringified array)
          const ballot = JSON.parse(ballotStr);
          // Add the count to each candidate in this ballot
          ballot.forEach(candId => {
            if (voteCounts[parseInt(candId)] !== undefined) {
              voteCounts[parseInt(candId)] += count;
            }
          });
        });
      } else if (round.votes_per_candidate) {
        // Fallback to votes_per_candidate for first round if needed
        Object.entries(round.votes_per_candidate).forEach(([candId, voters]) => {
          voteCounts[parseInt(candId)] = voters.length;
        });
      }
    }
    
    // Add stored thresholds for previous winners (display only, doesn't affect calculations)
    Object.entries(winnerThresholds).forEach(([winnerId, threshold]) => {
      voteCounts[parseInt(winnerId)] = threshold;
    });
    
    return {
      votes: voteCounts,
      winner: round.winner,
      isInitial: roundIndex === 0,
      roundNumber: roundIndex + 1
    };
  }
  
  // Function to get sorted candidate order
  function getSortedCandidateOrder(roundIndex, phase = 'initial') {
    const showRemovedBallots = (phase === 'remove_ballots');
    const roundData = prepareRoundData(roundIndex, showRemovedBallots);
    if (!roundData) return allCandidateIds;
    
    // Collect all winners up to this round
    const winners = [];
    for (let i = 0; i <= roundIndex; i++) {
      if (excessRounds[i] && excessRounds[i].winner) {
        winners.push(excessRounds[i].winner);
      }
    }
    
    // Sort candidates: winners first (in order they won), then others by vote count
    const sortedIds = [...allCandidateIds].sort((a, b) => {
      const aIsWinner = winners.includes(a);
      const bIsWinner = winners.includes(b);
      
      // If both are winners, maintain their winning order
      if (aIsWinner && bIsWinner) {
        return winners.indexOf(a) - winners.indexOf(b);
      }
      
      // Winners come first
      if (aIsWinner) return -1;
      if (bIsWinner) return 1;
      
      // Non-winners sorted by current vote count (descending)
      return roundData.votes[b] - roundData.votes[a];
    });
    
    return sortedIds;
  }
  
  // Create SVG
  const svg = d3.select("#chart")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", totalHeight)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);
  
  // Create scales (will be updated with sorted data)
  const x = d3.scaleBand()
    .range([0, width])
    .padding(0.1);
  
  // Calculate max votes across all rounds for consistent Y scale
  let maxVotes = 0;
  for (let i = 0; i < excessRounds.length; i++) {
    const roundData = prepareRoundData(i);
    if (roundData) {
      const roundMax = Math.max(...Object.values(roundData.votes));
      maxVotes = Math.max(maxVotes, roundMax);
    }
  }
  
  const y = d3.scaleLinear()
    .range([height, 0])
    .domain([0, maxVotes * 1.1]); // Add 10% padding
  
  // Add X axis (will be updated dynamically)
  const xAxisGroup = svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${height})`);
  
  // Add Y axis
  svg.append("g")
    .attr("transform", "translate(-10,0)")
    .call(d3.axisLeft(y)
      .ticks(Math.min(10, maxVotes))
      .tickFormat(d3.format("d")))
    .selectAll("text")
    .call(axisTextStyle);
  
  // Add Y axis title
  svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left - 5)
      .attr("x", 0 - (height / 2))
      .attr("dy", "1em")
      .call(axisTitleStyle)
      .text("Votes");
  
  // Add X axis title
  svg.append("text")
      .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
      .call(axisTitleStyle)
      .text("Candidates");
  
  // Container for bars (will be populated in updateChart)
  const barsGroup = svg.append("g").attr("class", "bars-group");
  
  // Container for winner markers
  const markersGroup = svg.append("g").attr("class", "markers-group");
  
  // Function to update the chart
  function updateChart(roundIndex, phase = 'initial') {
    const showRemovedBallots = (phase === 'remove_ballots');
    let roundData = prepareRoundData(roundIndex, showRemovedBallots);
    if (!roundData) return;
    
    // For remove_excess phase, stay on the current round but show winner with reduced votes
    if (phase === 'remove_excess' && roundIndex < excessRounds.length) {
      // Use current round data but modify the winner's votes to threshold
      roundData = prepareRoundData(roundIndex, false);
      if (roundData && roundData.winner && roundData.winner in winnerThresholds) {
        roundData = {...roundData};
        roundData.votes = {...roundData.votes};
        roundData.votes[roundData.winner] = winnerThresholds[roundData.winner];
      }
    }
    
    // Get sorted candidate order for this round
    const sortedIds = getSortedCandidateOrder(roundIndex, phase);
    const sortedLabels = sortedIds.map(id => candidates[id]);
    
    // Update X scale domain with sorted labels
    x.domain(sortedLabels);
    
    // Update X axis with transition
    xAxisGroup
      .transition()
      .duration(800)
      .call(d3.axisBottom(x))
      .selectAll("text")
      .style("text-anchor", "middle")
      .call(axisTextStyle)
      .attr("y", 30)
      .each(function(d, index, nodes) {
        const words = d.split(/\s+/);
        const numBars = nodes.length;
        const maxChars = 80 / numBars;
        let lines = [];
        let currentLine = words[0];

        for(let i = 1; i < words.length; i++) {
          if (currentLine.length + words[i].length + 1 <= maxChars) {
            currentLine += " " + words[i];
          } else {
            lines.push(currentLine);
            currentLine = words[i];
          }
        }
        lines.push(currentLine);

        d3.select(this).text(null);
        lines.forEach((line, i) => {
          d3.select(this)
            .append("tspan")
            .attr("x", 0)
            .attr("dy", i === 0 ? 0 : "1.2em")
            .text(line);
        });
      });
    
    // Collect winners based on phase
    const winners = [];
    
    // Only include winners that have been officially selected (during or after 'winner' phase)
    if (phase === 'remove_excess') {
      // For remove_excess, include all winners up to and including current round
      for (let i = 0; i <= roundIndex; i++) {
        if (excessRounds[i] && excessRounds[i].winner) {
          winners.push(excessRounds[i].winner);
        }
      }
    } else if (phase === 'remove_ballots' || phase === 'add_excess') {
      // During these phases, only count winners from previous rounds
      for (let i = 0; i < roundIndex; i++) {
        if (excessRounds[i] && excessRounds[i].winner) {
          winners.push(excessRounds[i].winner);
        }
      }
    } else {
      // During initial and winner phases, include all winners up to current round
      for (let i = 0; i <= roundIndex; i++) {
        if (excessRounds[i] && excessRounds[i].winner) {
          // Only include current round winner if we're in 'winner' phase
          if (i < roundIndex || phase === 'winner') {
            winners.push(excessRounds[i].winner);
          }
        }
      }
    }
    
    // Update bars with data join
    const bars = barsGroup.selectAll(".bar")
      .data(sortedIds, d => d); // Use candidate ID as key
    
    // Remove exiting bars
    bars.exit()
      .transition()
      .duration(400)
      .attr("height", 0)
      .attr("y", height)
      .remove();
    
    // Add new bars
    const barsEnter = bars.enter()
      .append("rect")
      .attr("class", "bar")
      .attr("x", d => x(candidates[d]))
      .attr("y", height)
      .attr("width", x.bandwidth())
      .attr("height", 0)
      .attr("rx", 4)
      .attr("ry", 4);
    
    // Update all bars (existing + new)
    bars.merge(barsEnter)
      .transition()
      .duration(800)
      .attr("x", d => x(candidates[d]))
      .attr("y", d => y(roundData.votes[d]))
      .attr("width", x.bandwidth())
      .attr("height", d => height - y(roundData.votes[d]))
      .attr("fill", d => {
        if (phase === 'winner' && d === roundData.winner) {
          return "#10B981"; // Green for new winner
        } else if (winners.includes(d)) {
          return "#10B981"; // Keep winners green
        }
        return "#2563EB"; // Blue for others
      });
    
    // Update winner markers
    const markers = markersGroup.selectAll(".winner-marker")
      .data(sortedIds, d => d);
    
    markers.exit().remove();
    
    const markersEnter = markers.enter()
      .append("text")
      .attr("class", "winner-marker")
      .attr("text-anchor", "middle")
      .style("font-size", "24px")
      .style("opacity", 0)
      .text("👑");
    
    markers.merge(markersEnter)
      .transition()
      .duration(400)
      .attr("x", d => x(candidates[d]) + x.bandwidth() / 2)
      .attr("y", d => {
        const voteHeight = y(roundData.votes[d]);
        return voteHeight - 10;
      })
      .style("opacity", d => winners.includes(d) ? 1 : 0);
    
    // Update tooltips
    barsGroup.selectAll(".bar")
      .selectAll("title").remove();
    barsGroup.selectAll(".bar")
      .append("title")
      .text(d => `${candidates[d]}: ${roundData.votes[d].toFixed(1)} votes`);
    
    // Update round label
    document.getElementById('roundLabel').textContent = `Round ${roundData.roundNumber}`;
    
    // Update round description
    const roundInfo = document.getElementById('roundDescription');
    if (phase === 'initial' && roundIndex === 0) {
      roundInfo.innerHTML = `<strong>Initial vote counts:</strong> Each candidate's total votes from all ballots.`;
    } else if (phase === 'initial' && roundIndex > 0) {
      roundInfo.innerHTML = `<strong>Round ${roundData.roundNumber} begins:</strong> Continuing with remaining candidates after redistributing excess votes.`;
    } else if (phase === 'winner') {
      const winnerName = candidates[roundData.winner];
      const winnerVotes = roundData.votes[roundData.winner];
      
      // Find runner-up (highest non-winner votes)
      let runnerUpVotes = 0;
      let runnerUpId = null;
      Object.entries(roundData.votes).forEach(([candId, votes]) => {
        const id = parseInt(candId);
        if (id !== roundData.winner && votes > runnerUpVotes && !(id in winnerThresholds)) {
          runnerUpVotes = votes;
          runnerUpId = id;
        }
      });
      
      // Store the threshold for this winner
      winnerThresholds[roundData.winner] = runnerUpVotes;
      
      const excess = winnerVotes - runnerUpVotes;
      const isFinalRound = roundIndex >= excessRounds.length - 1;
      
      if (excess > 0) {
        if (isFinalRound) {
          // Final round - no redistribution will happen
          roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes).`;
        } else {
          // Not final round - redistribution will happen
          roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes). The ${excess.toFixed(1)} excess votes will be redistributed.`;
        }
      } else {
        roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes (tied with runner-up).`;
      }
    } else if (phase === 'remove_excess') {
      const winnerName = candidates[roundData.winner];
      const winnerId = roundData.winner;
      
      // Calculate the excess
      let originalWinnerVotes = 0;
      if (excessRounds[roundIndex].votes_per_candidate && excessRounds[roundIndex].votes_per_candidate[winnerId]) {
        originalWinnerVotes = excessRounds[roundIndex].votes_per_candidate[winnerId].length;
      }
      const threshold = winnerThresholds[winnerId];
      const excess = originalWinnerVotes - threshold;
      
      roundInfo.innerHTML = `<strong>Removing excess votes:</strong> ${winnerName} keeps ${threshold.toFixed(1)} votes (the threshold). The ${excess.toFixed(1)} excess votes above the threshold will be redistributed.`;
    } else if (phase === 'remove_ballots') {
      if (roundIndex > 0) {
        const prevWinner = excessRounds[roundIndex - 1].winner;
        const prevWinnerName = candidates[prevWinner];
        roundInfo.innerHTML = `<strong>Removing winner's ballots:</strong> All ballots that included ${prevWinnerName} have been removed. The remaining candidates now show their votes from ballots that didn't include ${prevWinnerName}.`;
      }
    } else if (phase === 'add_excess') {
      if (roundIndex > 0) {
        const prevWinner = excessRounds[roundIndex - 1].winner;
        const prevWinnerName = candidates[prevWinner];
        
        // Calculate the excess
        let originalWinnerVotes = 0;
        if (excessRounds[roundIndex - 1].votes_per_candidate && excessRounds[roundIndex - 1].votes_per_candidate[prevWinner]) {
          originalWinnerVotes = excessRounds[roundIndex - 1].votes_per_candidate[prevWinner].length;
        }
        const threshold = winnerThresholds[prevWinner];
        const excess = originalWinnerVotes - threshold;
        
        roundInfo.innerHTML = `<strong>Adding excess votes:</strong> The ${excess.toFixed(1)} excess votes from ${prevWinnerName} are being redistributed to the remaining candidates based on which other candidates ${prevWinnerName}'s supporters voted for.`;
      } else {
        roundInfo.innerHTML = `<strong>All seats filled!</strong> The election is complete with ${seats} winner${seats > 1 ? 's' : ''}.`;
      }
    }
  }
  
  // Animation functions
  function nextStep() {
    if (currentPhase === 'initial') {
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    } else if (currentPhase === 'winner') {
      if (currentRound < excessRounds.length - 1) {
        // Move to remove_excess phase (stay on same round)
        currentPhase = 'remove_excess';
        updateChart(currentRound, 'remove_excess');
      } else {
        // Animation complete - stop and schedule reset
        stopAnimation();
        setTimeout(() => {
          resetAnimation();
        }, 3000); // Wait 3 seconds before resetting
      }
    } else if (currentPhase === 'remove_excess') {
      // Now move to next round for remove_ballots
      currentRound++;
      currentPhase = 'remove_ballots';
      updateChart(currentRound, 'remove_ballots');
    } else if (currentPhase === 'remove_ballots') {
      currentPhase = 'add_excess';
      updateChart(currentRound, 'add_excess');
    } else if (currentPhase === 'add_excess') {
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    }
  }
  
  function prevStep() {
    if (currentPhase === 'initial' && currentRound > 0) {
      currentPhase = 'add_excess';
      updateChart(currentRound, 'add_excess');
    } else if (currentPhase === 'add_excess') {
      currentPhase = 'remove_ballots';
      updateChart(currentRound, 'remove_ballots');
    } else if (currentPhase === 'remove_ballots') {
      currentPhase = 'remove_excess';
      updateChart(currentRound, 'remove_excess');
    } else if (currentPhase === 'remove_excess') {
      currentRound--;
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    } else if (currentPhase === 'winner') {
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    }
  }
  
  function playAnimation() {
    isPlaying = true;
    document.getElementById('playBtn').textContent = 'Pause';
    animationTimer = setInterval(() => {
      nextStep();
      // Check if we've reached the end
      if (currentRound >= excessRounds.length - 1 && currentPhase === 'winner') {
        // Will auto-reset after showing final state
        return;
      }
    }, 3000); // 3 seconds per step to allow time to read captions
  }
  
  function stopAnimation() {
    isPlaying = false;
    document.getElementById('playBtn').textContent = 'Play Animation';
    if (animationTimer) {
      clearInterval(animationTimer);
      animationTimer = null;
    }
  }
  
  function resetAnimation() {
    stopAnimation();
    currentRound = 0;
    currentPhase = 'initial';
    // Clear stored winner thresholds
    for (let key in winnerThresholds) {
      delete winnerThresholds[key];
    }
    updateChart(0, 'initial');
  }
  
  // Event listeners
  document.getElementById('playBtn').addEventListener('click', () => {
    if (isPlaying) {
      stopAnimation();
    } else {
      playAnimation();
    }
  });
  
  document.getElementById('resetBtn').addEventListener('click', resetAnimation);
  document.getElementById('nextBtn').addEventListener('click', () => {
    stopAnimation();
    nextStep();
  });
  document.getElementById('prevBtn').addEventListener('click', () => {
    stopAnimation();
    prevStep();
  });
  
  // Initialize with first round
  updateChart(0, 'initial');
  
  // Set container height
  d3.select("#chart")
    .style("height", totalHeight + "px")
    .style("margin-bottom", "2rem");
</script>
{% endblock %}