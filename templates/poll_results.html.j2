{% extends "base.html.j2" %}

{% block content %}
<div class="space-y-4">
  <h1 class="text-3xl font-medium">{{title}}</h1>
  <p class="text-lg text-gray-500">{{description}}</p>
  <p class="text-lg">Poll results: {{winners}}</p>
  <div class="container mx-auto px-4">
    <div style="display: flex; justify-content: space-around; gap-20px;">
      <div style="flex: 1;">
        <h2 class="text-2xl font-bold mb-4">Votes</h2>
        <p>Here is an animated visualization of the multi-winner approval voting process. Watch as winners are selected and excess votes are redistributed in each round.</p>
        
        <!-- Animation controls -->
        <div class="flex gap-4 mb-4 items-center">
          <button id="playBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
            Play Animation
          </button>
          <button id="resetBtn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
            Reset
          </button>
          <button id="prevBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            ← Previous
          </button>
          <button id="nextBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            Next →
          </button>
          <span id="roundLabel" class="font-medium text-gray-700 ml-4">Round 1</span>
        </div>
        
        <div id="chart"></div>
        
        <!-- Round information display -->
        <div id="roundInfo" class="mt-4 p-4 bg-gray-50 rounded-lg">
          <div id="roundDescription" class="text-gray-700"></div>
        </div>
      </div>
    </div>
  </div>
  <hr />

  <h2 class="text-2xl font-medium">Did you have a different preferred result?</h2>
  <div class="bg-gray-50 rounded-3xl p-8 border border-gray-300 space-y-4">
    <p>You can see how many more votes the winners got than your preferred result. What was your preferred result?</p>
    <form hx-post="/resultsubmit" hx-target="#resultresponse" hx-swap="innerHTML">
      <input type="hidden" name="poll_id" value="{{ poll_id }}" />
      <input type="hidden" name="seats" value="{{ seats }}" />
      {% for id, candidate in candidates.items() %}
      <label>
        <input type="checkbox" name="poll_option" value="{{id}}|{{candidate}}" /> {{candidate}}
      </label>
      <br />
      {% endfor %}
    </div>
    <button type="resultsubmit" class="btn-primary">See how close your preferred candidates were to winning</button>
  </form>
  <div id="resultresponse"></div>
  
  <div class="mt-8">
    <a href="{{ url_for('download_votes_csv', poll_id=poll_id) }}" class="text-blue-600 border border-blue-600 hover:bg-blue-50 font-medium px-6 py-4 rounded-full transition duration-150 ease-in-out inline-block">Download votes</a>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ url_for('static', filename='js/chartStyles.js') }}"></script>
<script>
  // Parse data from Jinja
  const candidates = {{ candidates|tojson }};
  const excessRounds = {{ excess_rounds|tojson }};
  const seats = {{ seats }};
  
  // Set dimensions
  const margin = {top: 20, right: 20, bottom: 80, left: 60};
  const width = 800 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;
  const totalHeight = height + margin.top + margin.bottom;
  
  // Animation state
  let currentRound = 0;
  let currentPhase = 'initial'; // 'initial', 'winner', 'redistribute'
  let isPlaying = false;
  let animationTimer = null;
  
  // Get all candidate IDs
  const allCandidateIds = Object.keys(candidates).map(id => parseInt(id));
  
  // Prepare data for each round
  function prepareRoundData(roundIndex) {
    if (roundIndex >= excessRounds.length) return null;
    
    const round = excessRounds[roundIndex];
    const voteCounts = {};
    
    // Initialize all candidates with 0
    allCandidateIds.forEach(id => {
      voteCounts[id] = 0;
    });
    
    // Calculate votes from the round's votes_per_candidate
    if (round.votes_per_candidate) {
      Object.entries(round.votes_per_candidate).forEach(([candId, voters]) => {
        // voters is now an array after JSON conversion
        voteCounts[parseInt(candId)] = voters.length;
      });
    }
    
    return {
      votes: voteCounts,
      winner: round.winner,
      isInitial: roundIndex === 0,
      roundNumber: roundIndex + 1
    };
  }
  
  // Function to get sorted candidate order
  function getSortedCandidateOrder(roundIndex) {
    const roundData = prepareRoundData(roundIndex);
    if (!roundData) return allCandidateIds;
    
    // Collect all winners up to this round
    const winners = [];
    for (let i = 0; i <= roundIndex; i++) {
      if (excessRounds[i] && excessRounds[i].winner) {
        winners.push(excessRounds[i].winner);
      }
    }
    
    // Sort candidates: winners first (in order they won), then others by vote count
    const sortedIds = [...allCandidateIds].sort((a, b) => {
      const aIsWinner = winners.includes(a);
      const bIsWinner = winners.includes(b);
      
      // If both are winners, maintain their winning order
      if (aIsWinner && bIsWinner) {
        return winners.indexOf(a) - winners.indexOf(b);
      }
      
      // Winners come first
      if (aIsWinner) return -1;
      if (bIsWinner) return 1;
      
      // Non-winners sorted by current vote count (descending)
      return roundData.votes[b] - roundData.votes[a];
    });
    
    return sortedIds;
  }
  
  // Create SVG
  const svg = d3.select("#chart")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", totalHeight)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);
  
  // Create scales (will be updated with sorted data)
  const x = d3.scaleBand()
    .range([0, width])
    .padding(0.1);
  
  // Calculate max votes across all rounds for consistent Y scale
  let maxVotes = 0;
  for (let i = 0; i < excessRounds.length; i++) {
    const roundData = prepareRoundData(i);
    if (roundData) {
      const roundMax = Math.max(...Object.values(roundData.votes));
      maxVotes = Math.max(maxVotes, roundMax);
    }
  }
  
  const y = d3.scaleLinear()
    .range([height, 0])
    .domain([0, maxVotes * 1.1]); // Add 10% padding
  
  // Add X axis (will be updated dynamically)
  const xAxisGroup = svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${height})`);
  
  // Add Y axis
  svg.append("g")
    .attr("transform", "translate(-10,0)")
    .call(d3.axisLeft(y)
      .ticks(Math.min(10, maxVotes))
      .tickFormat(d3.format("d")))
    .selectAll("text")
    .call(axisTextStyle);
  
  // Add Y axis title
  svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left - 5)
      .attr("x", 0 - (height / 2))
      .attr("dy", "1em")
      .call(axisTitleStyle)
      .text("Votes");
  
  // Add X axis title
  svg.append("text")
      .attr("transform", `translate(${width/2}, ${height + margin.bottom})`)
      .call(axisTitleStyle)
      .text("Candidates");
  
  // Container for bars (will be populated in updateChart)
  const barsGroup = svg.append("g").attr("class", "bars-group");
  
  // Container for winner markers
  const markersGroup = svg.append("g").attr("class", "markers-group");
  
  // Function to update the chart
  function updateChart(roundIndex, phase = 'initial') {
    const roundData = prepareRoundData(roundIndex);
    if (!roundData) return;
    
    // Get sorted candidate order for this round
    const sortedIds = getSortedCandidateOrder(roundIndex);
    const sortedLabels = sortedIds.map(id => candidates[id]);
    
    // Update X scale domain with sorted labels
    x.domain(sortedLabels);
    
    // Update X axis with transition
    xAxisGroup
      .transition()
      .duration(800)
      .call(d3.axisBottom(x))
      .selectAll("text")
      .style("text-anchor", "middle")
      .call(axisTextStyle)
      .attr("y", 30)
      .each(function(d, index, nodes) {
        const words = d.split(/\s+/);
        const numBars = nodes.length;
        const maxChars = 80 / numBars;
        let lines = [];
        let currentLine = words[0];

        for(let i = 1; i < words.length; i++) {
          if (currentLine.length + words[i].length + 1 <= maxChars) {
            currentLine += " " + words[i];
          } else {
            lines.push(currentLine);
            currentLine = words[i];
          }
        }
        lines.push(currentLine);

        d3.select(this).text(null);
        lines.forEach((line, i) => {
          d3.select(this)
            .append("tspan")
            .attr("x", 0)
            .attr("dy", i === 0 ? 0 : "1.2em")
            .text(line);
        });
      });
    
    const winners = [];
    for (let i = 0; i <= roundIndex; i++) {
      if (excessRounds[i] && excessRounds[i].winner) {
        winners.push(excessRounds[i].winner);
      }
    }
    
    // Update bars with data join
    const bars = barsGroup.selectAll(".bar")
      .data(sortedIds, d => d); // Use candidate ID as key
    
    // Remove exiting bars
    bars.exit()
      .transition()
      .duration(400)
      .attr("height", 0)
      .attr("y", height)
      .remove();
    
    // Add new bars
    const barsEnter = bars.enter()
      .append("rect")
      .attr("class", "bar")
      .attr("x", d => x(candidates[d]))
      .attr("y", height)
      .attr("width", x.bandwidth())
      .attr("height", 0)
      .attr("rx", 4)
      .attr("ry", 4);
    
    // Update all bars (existing + new)
    bars.merge(barsEnter)
      .transition()
      .duration(800)
      .attr("x", d => x(candidates[d]))
      .attr("y", d => y(roundData.votes[d]))
      .attr("width", x.bandwidth())
      .attr("height", d => height - y(roundData.votes[d]))
      .attr("fill", d => {
        if (phase === 'winner' && d === roundData.winner) {
          return "#10B981"; // Green for new winner
        } else if (winners.includes(d)) {
          return "#10B981"; // Keep winners green
        }
        return "#2563EB"; // Blue for others
      });
    
    // Update winner markers
    const markers = markersGroup.selectAll(".winner-marker")
      .data(sortedIds, d => d);
    
    markers.exit().remove();
    
    const markersEnter = markers.enter()
      .append("text")
      .attr("class", "winner-marker")
      .attr("text-anchor", "middle")
      .style("font-size", "24px")
      .style("opacity", 0)
      .text("👑");
    
    markers.merge(markersEnter)
      .transition()
      .duration(400)
      .attr("x", d => x(candidates[d]) + x.bandwidth() / 2)
      .attr("y", d => {
        const voteHeight = y(roundData.votes[d]);
        return voteHeight - 10;
      })
      .style("opacity", d => winners.includes(d) ? 1 : 0);
    
    // Update tooltips
    barsGroup.selectAll(".bar")
      .selectAll("title").remove();
    barsGroup.selectAll(".bar")
      .append("title")
      .text(d => `${candidates[d]}: ${roundData.votes[d].toFixed(1)} votes`);
    
    // Update round label
    document.getElementById('roundLabel').textContent = `Round ${roundData.roundNumber}`;
    
    // Update round description
    const roundInfo = document.getElementById('roundDescription');
    if (phase === 'initial' && roundIndex === 0) {
      roundInfo.innerHTML = `<strong>Initial vote counts:</strong> Each candidate's total votes from all ballots.`;
    } else if (phase === 'winner') {
      const winnerName = candidates[roundData.winner];
      roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} has the most votes this round and wins a seat!`;
    } else if (phase === 'redistribute') {
      if (roundIndex < excessRounds.length - 1) {
        roundInfo.innerHTML = `<strong>Redistributing excess votes:</strong> Votes exceeding the threshold are redistributed proportionally to remaining candidates based on ballot combinations.`;
      } else {
        roundInfo.innerHTML = `<strong>All seats filled!</strong> The election is complete with ${seats} winner${seats > 1 ? 's' : ''}.`;
      }
    }
  }
  
  // Animation functions
  function nextStep() {
    if (currentPhase === 'initial') {
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    } else if (currentPhase === 'winner') {
      if (currentRound < excessRounds.length - 1) {
        currentPhase = 'redistribute';
        updateChart(currentRound, 'redistribute');
      } else {
        // Animation complete - stop and schedule reset
        stopAnimation();
        setTimeout(() => {
          resetAnimation();
        }, 3000); // Wait 3 seconds before resetting
      }
    } else if (currentPhase === 'redistribute') {
      currentRound++;
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    }
  }
  
  function prevStep() {
    if (currentPhase === 'initial' && currentRound > 0) {
      currentRound--;
      currentPhase = 'redistribute';
      updateChart(currentRound, 'redistribute');
    } else if (currentPhase === 'winner') {
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    } else if (currentPhase === 'redistribute') {
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    }
  }
  
  function playAnimation() {
    isPlaying = true;
    document.getElementById('playBtn').textContent = 'Pause';
    animationTimer = setInterval(() => {
      nextStep();
      // Check if we've reached the end
      if (currentRound >= excessRounds.length - 1 && currentPhase === 'winner') {
        // Will auto-reset after showing final state
        return;
      }
    }, 2000); // 2 seconds per step
  }
  
  function stopAnimation() {
    isPlaying = false;
    document.getElementById('playBtn').textContent = 'Play Animation';
    if (animationTimer) {
      clearInterval(animationTimer);
      animationTimer = null;
    }
  }
  
  function resetAnimation() {
    stopAnimation();
    currentRound = 0;
    currentPhase = 'initial';
    updateChart(0, 'initial');
  }
  
  // Event listeners
  document.getElementById('playBtn').addEventListener('click', () => {
    if (isPlaying) {
      stopAnimation();
    } else {
      playAnimation();
    }
  });
  
  document.getElementById('resetBtn').addEventListener('click', resetAnimation);
  document.getElementById('nextBtn').addEventListener('click', () => {
    stopAnimation();
    nextStep();
  });
  document.getElementById('prevBtn').addEventListener('click', () => {
    stopAnimation();
    prevStep();
  });
  
  // Initialize with first round
  updateChart(0, 'initial');
  
  // Set container height
  d3.select("#chart")
    .style("height", totalHeight + "px")
    .style("margin-bottom", "2rem");
</script>
{% endblock %}