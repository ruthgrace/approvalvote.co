{% extends "base.html.j2" %}

{% block content %}
<div class="space-y-4">
  <h1 class="text-3xl font-medium">{{poll_name}}</h1>
  <p class="text-lg text-gray-500">{{poll_description}}</p>
  
  {% if no_votes %}
  <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-6 text-left">
    <p class="text-xl text-gray-700">This poll has no votes yet.</p>
    <p class="text-gray-600 mt-2">Be the first to vote!</p>
    <a href="/poll/{{poll_id}}" class="inline-block mt-4 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
      Vote Now
    </a>
  </div>
  {% else %}
  <p class="text-lg">Poll results: {{winners}}</p>
  <div class="container mx-auto px-4">
    <div style="display: flex; justify-content: space-around; gap-20px;">
      <div style="flex: 1;">
        <h2 class="text-2xl font-bold mb-4">Votes</h2>
        <p>Here is an animated visualization of the multi-winner approval voting process. Watch as winners are selected and excess votes are redistributed in each round.</p>
        
        <!-- Animation controls -->
        <div class="flex gap-4 mb-4 items-center">
          <button id="playBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700">
            Play Animation
          </button>
          <button id="resetBtn" class="px-4 py-2 bg-gray-600 text-white rounded-lg hover:bg-gray-700">
            Reset
          </button>
          <button id="prevBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            ← Previous
          </button>
          <button id="nextBtn" class="px-3 py-2 bg-gray-500 text-white rounded-lg hover:bg-gray-600">
            Next →
          </button>
          <span id="roundLabel" class="font-medium text-gray-700 ml-4">Round 1</span>
        </div>
        
        <!-- Round information display (moved above chart) -->
        <div id="roundInfo" class="mb-4 p-4 bg-gray-50 rounded-lg">
          <div id="roundDescription" class="text-gray-700"></div>
        </div>
        
        <div id="chart"></div>
      </div>
    </div>
  </div>
  <hr />

  <h2 class="text-2xl font-medium">Did you have a different preferred result?</h2>
  <div class="bg-gray-50 rounded-3xl p-8 border border-gray-300 space-y-4">
    <p>Select your preferred candidate to see how many votes they were short of winning each position.</p>
    <form hx-post="/resultsubmit" hx-target="#resultresponse" hx-swap="innerHTML">
      <input type="hidden" name="poll_id" value="{{ poll_id }}" />
      <input type="hidden" name="seats" value="{{ seats }}" />
      {% for id, candidate in candidates.items() %}
      <label class="block py-1">
        <input type="radio" name="poll_option" value="{{id}}|{{candidate}}" class="mr-2" /> {{candidate}}
      </label>
      {% endfor %}
    </div>
    <button type="submit" class="btn-primary">See how close your preferred candidate was to winning</button>
  </form>
  <div id="resultresponse"></div>
  
  <div class="mt-8">
    <a href="{{ url_for('download_votes_csv', poll_id=poll_id) }}" class="text-blue-600 border border-blue-600 hover:bg-blue-50 font-medium px-6 py-4 rounded-full transition duration-150 ease-in-out inline-block">Download votes</a>
  </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="{{ url_for('static', filename='js/chartStyles.js') }}"></script>
<script>
  // Parse data from Jinja
  const candidates = {{ candidates|tojson }};
  const excessRounds = {{ excess_rounds|tojson }};
  const seats = {{ seats }};
  
  // Set dimensions
  const margin = {top: 20, right: 20, bottom: 120, left: 60};
  const width = 800 - margin.left - margin.right;
  const height = 400 - margin.top - margin.bottom;
  const totalHeight = height + margin.top + margin.bottom;
  
  // Animation state
  let currentRound = 0;
  let currentPhase = 'initial'; // 'initial', 'winner', 'remove_excess', 'remove_ballots', 'add_excess'
  let isPlaying = false;
  let animationTimer = null;
  
  // Store winner thresholds (the votes they retain after winning)
  const winnerThresholds = {};
  
  // Group rounds that are ties (have the same ballot_counts)
  function groupTiedRounds() {
    const groupedRounds = [];
    let i = 0;
    
    while (i < excessRounds.length) {
      const currentRoundData = excessRounds[i];
      const tiedWinners = [currentRoundData.winner];
      
      // Check if next rounds have the same ballot_counts (indicating a tie)
      let j = i + 1;
      while (j < excessRounds.length) {
        const nextRound = excessRounds[j];
        // Compare ballot_counts to see if they're the same
        if (JSON.stringify(currentRoundData.ballot_counts) === JSON.stringify(nextRound.ballot_counts)) {
          tiedWinners.push(nextRound.winner);
          j++;
        } else {
          break;
        }
      }
      
      groupedRounds.push({
        ...currentRoundData,
        winners: tiedWinners,  // Array of all tied winners
        isTie: tiedWinners.length > 1,
        originalRoundIndex: i
      });
      
      i = j;
    }
    
    return groupedRounds;
  }
  
  // Use grouped rounds for animation
  const animationRounds = groupTiedRounds();
  
  // Get all candidate IDs
  const allCandidateIds = Object.keys(candidates).map(id => parseInt(id));
  
  // Prepare data for each round
  function prepareRoundData(roundIndex, showRemovedBallots = false) {
    if (roundIndex >= animationRounds.length) return null;
    
    const round = animationRounds[roundIndex];
    const voteCounts = {};
    
    // Initialize all candidates with 0
    allCandidateIds.forEach(id => {
      voteCounts[id] = 0;
    });
    
    if (showRemovedBallots && roundIndex > 0) {
      // Show the state after removing winner's ballots but before adding excess
      // This shows what happens when we remove all ballots containing the previous winners
      const prevRound = animationRounds[roundIndex - 1];
      
      // Get ballots that DON'T contain any of the previous winners
      if (prevRound.ballot_counts) {
        Object.entries(prevRound.ballot_counts).forEach(([ballotStr, count]) => {
          const ballot = JSON.parse(ballotStr);
          // Only count ballots that don't include any of the previous winners
          const includesWinner = prevRound.winners.some(winner => ballot.includes(winner));
          if (!includesWinner) {
            ballot.forEach(candId => {
              if (voteCounts[parseInt(candId)] !== undefined) {
                voteCounts[parseInt(candId)] += count;
              }
            });
          }
        });
      }
    } else {
      // Normal calculation
      // Calculate votes from ballot_counts (which has the redistributed votes)
      if (round.ballot_counts) {
        Object.entries(round.ballot_counts).forEach(([ballotStr, count]) => {
          // Parse the ballot string (it's a stringified array)
          const ballot = JSON.parse(ballotStr);
          // Add the count to each candidate in this ballot
          ballot.forEach(candId => {
            if (voteCounts[parseInt(candId)] !== undefined) {
              voteCounts[parseInt(candId)] += count;
            }
          });
        });
      } else if (round.votes_per_candidate) {
        // Fallback to votes_per_candidate for first round if needed
        Object.entries(round.votes_per_candidate).forEach(([candId, voters]) => {
          voteCounts[parseInt(candId)] = voters.length;
        });
      }
    }
    
    // Add stored thresholds for previous winners (display only, doesn't affect calculations)
    Object.entries(winnerThresholds).forEach(([winnerId, threshold]) => {
      voteCounts[parseInt(winnerId)] = threshold;
    });
    
    return {
      votes: voteCounts,
      winners: round.winners,  // Array of winners (multiple if tie)
      isInitial: roundIndex === 0,
      roundNumber: roundIndex + 1,
      isTie: round.isTie
    };
  }
  
  // Function to get sorted candidate order
  function getSortedCandidateOrder(roundIndex, phase = 'initial') {
    const showRemovedBallots = (phase === 'remove_ballots');
    const roundData = prepareRoundData(roundIndex, showRemovedBallots);
    if (!roundData) return allCandidateIds;
    
    // Collect all winners up to this round
    const winners = [];
    for (let i = 0; i <= roundIndex; i++) {
      if (animationRounds[i] && animationRounds[i].winners) {
        winners.push(...animationRounds[i].winners);
      }
    }
    
    // Sort candidates: winners first (in order they won), then others by vote count
    const sortedIds = [...allCandidateIds].sort((a, b) => {
      const aIsWinner = winners.includes(a);
      const bIsWinner = winners.includes(b);
      
      // If both are winners, maintain their winning order
      if (aIsWinner && bIsWinner) {
        return winners.indexOf(a) - winners.indexOf(b);
      }
      
      // Winners come first
      if (aIsWinner) return -1;
      if (bIsWinner) return 1;
      
      // Non-winners sorted by current vote count (descending)
      return roundData.votes[b] - roundData.votes[a];
    });
    
    return sortedIds;
  }
  
  // Create SVG
  const svg = d3.select("#chart")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", totalHeight)
    .append("g")
      .attr("transform", `translate(${margin.left},${margin.top})`);
  
  // Create scales (will be updated with sorted data)
  const x = d3.scaleBand()
    .range([0, width])
    .padding(0.1);
  
  // Calculate max votes across all rounds for consistent Y scale
  let maxVotes = 0;
  for (let i = 0; i < animationRounds.length; i++) {
    const roundData = prepareRoundData(i);
    if (roundData) {
      const roundMax = Math.max(...Object.values(roundData.votes));
      maxVotes = Math.max(maxVotes, roundMax);
    }
  }
  
  const y = d3.scaleLinear()
    .range([height, 0])
    .domain([0, maxVotes * 1.1]); // Add 10% padding
  
  // Add X axis (will be updated dynamically)
  const xAxisGroup = svg.append("g")
    .attr("class", "x-axis")
    .attr("transform", `translate(0,${height})`);
  
  // Add Y axis
  svg.append("g")
    .attr("transform", "translate(-10,0)")
    .call(d3.axisLeft(y)
      .ticks(Math.min(10, maxVotes))
      .tickFormat(d3.format("d")))
    .selectAll("text")
    .call(axisTextStyle);
  
  // Add Y axis title
  svg.append("text")
      .attr("transform", "rotate(-90)")
      .attr("y", 0 - margin.left - 5)
      .attr("x", 0 - (height / 2))
      .attr("dy", "1em")
      .call(axisTitleStyle)
      .text("Votes");
  
  // Add X axis title (will be positioned dynamically)
  const xAxisTitle = svg.append("text")
      .attr("class", "x-axis-title")
      .call(axisTitleStyle)
      .text("Candidates");
  
  // Container for bars (will be populated in updateChart)
  const barsGroup = svg.append("g").attr("class", "bars-group");
  
  // Container for winner markers
  const markersGroup = svg.append("g").attr("class", "markers-group");
  
  // Function to update the chart
  function updateChart(roundIndex, phase = 'initial') {
    const showRemovedBallots = (phase === 'remove_ballots');
    let roundData = prepareRoundData(roundIndex, showRemovedBallots);
    if (!roundData) return;
    
    // For remove_excess phase, stay on the current round but show winners with reduced votes
    if (phase === 'remove_excess' && roundIndex < animationRounds.length) {
      // Use current round data but modify the winners' votes to threshold
      roundData = prepareRoundData(roundIndex, false);
      if (roundData && roundData.winners) {
        roundData = {...roundData};
        roundData.votes = {...roundData.votes};
        // Apply threshold to all winners
        roundData.winners.forEach(winnerId => {
          if (winnerId in winnerThresholds) {
            roundData.votes[winnerId] = winnerThresholds[winnerId];
          }
        });
      }
    }
    
    // Get sorted candidate order for this round
    const sortedIds = getSortedCandidateOrder(roundIndex, phase);
    const sortedLabels = sortedIds.map(id => candidates[id]);
    
    // Update X scale domain with sorted labels
    x.domain(sortedLabels);
    
    // Update X axis without transition first
    xAxisGroup
      .call(d3.axisBottom(x));
    
    // Then apply styling and text wrapping to the text elements
    xAxisGroup.selectAll("text")
      .style("text-anchor", "middle")
      .call(axisTextStyle)
      .attr("y", 20)
      .each(function(d) {
        const text = d3.select(this);
        const words = d.split(/\s+/);
        const numBars = sortedLabels.length;
        
        // Calculate max characters based on number of bars
        let maxChars;
        if (numBars <= 5) {
          maxChars = 20;
        } else if (numBars <= 7) {
          maxChars = 12;
        } else {
          maxChars = 10;
        }
        
        let lines = [];
        let currentLine = "";

        for(let i = 0; i < words.length; i++) {
          const testLine = currentLine ? currentLine + " " + words[i] : words[i];
          if (testLine.length <= maxChars) {
            currentLine = testLine;
          } else {
            if (currentLine) lines.push(currentLine);
            currentLine = words[i];
          }
        }
        if (currentLine) lines.push(currentLine);

        // Clear and rebuild text with tspans
        text.text(null);
        lines.forEach((line, lineIndex) => {
          text.append("tspan")
            .attr("x", 0)
            .attr("dy", lineIndex === 0 ? "0" : "1.2em")
            .text(line);
        });
      });
    
    // Calculate the actual height of x-axis labels
    let maxLabelHeight = 0;
    xAxisGroup.selectAll("text").each(function() {
      const bbox = this.getBBox();
      maxLabelHeight = Math.max(maxLabelHeight, bbox.height);
    });
    
    // Position the X axis title just below the labels
    d3.select(".x-axis-title")
      .attr("transform", `translate(${width/2}, ${height + maxLabelHeight + 35})`);
    
    // Add transition to the axis group after text is set up
    xAxisGroup
      .transition()
      .duration(800);
    
    // Collect winners based on phase
    const winners = [];
    
    // Only include winners that have been officially selected (during or after 'winner' phase)
    if (phase === 'remove_excess') {
      // For remove_excess, include all winners up to and including current round
      for (let i = 0; i <= roundIndex; i++) {
        if (animationRounds[i] && animationRounds[i].winners) {
          winners.push(...animationRounds[i].winners);
        }
      }
    } else if (phase === 'remove_ballots' || phase === 'add_excess') {
      // During these phases, only count winners from previous rounds
      for (let i = 0; i < roundIndex; i++) {
        if (animationRounds[i] && animationRounds[i].winners) {
          winners.push(...animationRounds[i].winners);
        }
      }
    } else {
      // During initial and winner phases, include all winners up to current round
      for (let i = 0; i <= roundIndex; i++) {
        if (animationRounds[i] && animationRounds[i].winners) {
          // Only include current round winners if we're in 'winner' phase
          if (i < roundIndex || phase === 'winner') {
            winners.push(...animationRounds[i].winners);
          }
        }
      }
    }
    
    // Update bars with data join
    const bars = barsGroup.selectAll(".bar")
      .data(sortedIds, d => d); // Use candidate ID as key
    
    // Remove exiting bars
    bars.exit()
      .transition()
      .duration(400)
      .attr("height", 0)
      .attr("y", height)
      .remove();
    
    // Add new bars
    const barsEnter = bars.enter()
      .append("rect")
      .attr("class", "bar")
      .attr("x", d => x(candidates[d]))
      .attr("y", height)
      .attr("width", x.bandwidth())
      .attr("height", 0)
      .attr("rx", 4)
      .attr("ry", 4);
    
    // Update all bars (existing + new)
    bars.merge(barsEnter)
      .transition()
      .duration(800)
      .attr("x", d => x(candidates[d]))
      .attr("y", d => y(roundData.votes[d]))
      .attr("width", x.bandwidth())
      .attr("height", d => height - y(roundData.votes[d]))
      .attr("fill", d => {
        if (phase === 'winner' && roundData.winners.includes(d)) {
          return "#10B981"; // Green for new winners
        } else if (winners.includes(d)) {
          return "#10B981"; // Keep winners green
        }
        return "#2563EB"; // Blue for others
      });
    
    // Update winner markers
    const markers = markersGroup.selectAll(".winner-marker")
      .data(sortedIds, d => d);
    
    markers.exit().remove();
    
    const markersEnter = markers.enter()
      .append("text")
      .attr("class", "winner-marker")
      .attr("text-anchor", "middle")
      .style("font-size", "24px")
      .style("opacity", 0)
      .text("👑");
    
    markers.merge(markersEnter)
      .transition()
      .duration(400)
      .attr("x", d => x(candidates[d]) + x.bandwidth() / 2)
      .attr("y", d => {
        const voteHeight = y(roundData.votes[d]);
        return voteHeight - 10;
      })
      .style("opacity", d => winners.includes(d) ? 1 : 0);
    
    // Update tooltips
    barsGroup.selectAll(".bar")
      .selectAll("title").remove();
    barsGroup.selectAll(".bar")
      .append("title")
      .text(d => `${candidates[d]}: ${roundData.votes[d].toFixed(1)} votes`);
    
    // Update round label
    document.getElementById('roundLabel').textContent = `Round ${roundData.roundNumber}`;
    
    // Update round description
    const roundInfo = document.getElementById('roundDescription');
    if (phase === 'initial' && roundIndex === 0) {
      roundInfo.innerHTML = `<strong>Initial vote counts:</strong> Each candidate's total votes from all ballots.`;
    } else if (phase === 'initial' && roundIndex > 0) {
      roundInfo.innerHTML = `<strong>Round ${roundData.roundNumber} begins:</strong> Continuing with remaining candidates after redistributing excess votes.`;
    } else if (phase === 'winner') {
      // Handle multiple winners (ties)
      const winnerNames = roundData.winners.map(id => candidates[id]);
      const winnerVotes = roundData.votes[roundData.winners[0]]; // All tied winners have same votes
      
      // Find runner-up (highest non-winner votes)
      let runnerUpVotes = 0;
      let runnerUpId = null;
      Object.entries(roundData.votes).forEach(([candId, votes]) => {
        const id = parseInt(candId);
        if (!roundData.winners.includes(id) && votes > runnerUpVotes && !(id in winnerThresholds)) {
          runnerUpVotes = votes;
          runnerUpId = id;
        }
      });
      
      // Store the threshold for all winners
      roundData.winners.forEach(winnerId => {
        winnerThresholds[winnerId] = runnerUpVotes;
      });
      
      const excess = winnerVotes - runnerUpVotes;
      const isFinalRound = roundIndex >= animationRounds.length - 1;
      
      if (roundData.isTie) {
        // It's a tie
        const winnerNamesString = winnerNames.length === 2 
          ? `${winnerNames[0]} and ${winnerNames[1]}`
          : winnerNames.slice(0, -1).join(', ') + ', and ' + winnerNames[winnerNames.length - 1];
        
        if (excess > 0) {
          if (isFinalRound) {
            roundInfo.innerHTML = `<strong>Winners selected (tie):</strong> ${winnerNamesString} all win with ${winnerVotes.toFixed(1)} votes each, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes).`;
          } else {
            roundInfo.innerHTML = `<strong>Winners selected (tie):</strong> ${winnerNamesString} all win with ${winnerVotes.toFixed(1)} votes each, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes). The excess votes from all tied winners will be redistributed.`;
          }
        } else {
          roundInfo.innerHTML = `<strong>Winners selected (tie):</strong> ${winnerNamesString} all win with ${winnerVotes.toFixed(1)} votes each (all tied).`;
        }
      } else {
        // Single winner
        const winnerName = winnerNames[0];
        if (excess > 0) {
          if (isFinalRound) {
            roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes).`;
          } else {
            roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes, ${excess.toFixed(1)} more than the runner-up (${candidates[runnerUpId]} with ${runnerUpVotes.toFixed(1)} votes). The ${excess.toFixed(1)} excess votes will be redistributed.`;
          }
        } else {
          roundInfo.innerHTML = `<strong>Winner selected:</strong> ${winnerName} wins with ${winnerVotes.toFixed(1)} votes (tied with runner-up).`;
        }
      }
    } else if (phase === 'remove_excess') {
      const winnerNames = roundData.winners.map(id => candidates[id]);
      const winnerNamesString = winnerNames.length === 1 
        ? winnerNames[0]
        : winnerNames.length === 2 
          ? `${winnerNames[0]} and ${winnerNames[1]}`
          : winnerNames.slice(0, -1).join(', ') + ', and ' + winnerNames[winnerNames.length - 1];
      
      // Calculate the excess for first winner (all tied winners have same excess)
      const winnerId = roundData.winners[0];
      let originalWinnerVotes = 0;
      if (animationRounds[roundIndex].votes_per_candidate && animationRounds[roundIndex].votes_per_candidate[winnerId]) {
        originalWinnerVotes = animationRounds[roundIndex].votes_per_candidate[winnerId].length;
      }
      const threshold = winnerThresholds[winnerId];
      const excess = originalWinnerVotes - threshold;
      
      if (roundData.winners.length > 1) {
        roundInfo.innerHTML = `<strong>Removing excess votes:</strong> ${winnerNamesString} each keep ${threshold.toFixed(1)} votes (the threshold). The ${excess.toFixed(1)} excess votes from each winner will be redistributed.`;
      } else {
        roundInfo.innerHTML = `<strong>Removing excess votes:</strong> ${winnerNamesString} keeps ${threshold.toFixed(1)} votes (the threshold). The ${excess.toFixed(1)} excess votes above the threshold will be redistributed.`;
      }
    } else if (phase === 'remove_ballots') {
      if (roundIndex > 0) {
        const prevWinners = animationRounds[roundIndex - 1].winners;
        const prevWinnerNames = prevWinners.map(id => candidates[id]);
        const prevWinnerNamesString = prevWinnerNames.length === 1 
          ? prevWinnerNames[0]
          : prevWinnerNames.length === 2 
            ? `${prevWinnerNames[0]} or ${prevWinnerNames[1]}`
            : prevWinnerNames.slice(0, -1).join(', ') + ', or ' + prevWinnerNames[prevWinnerNames.length - 1];
        
        if (prevWinners.length > 1) {
          roundInfo.innerHTML = `<strong>Removing winners' ballots:</strong> All ballots that included any of the tied winners (${prevWinnerNamesString}) have been removed. The remaining candidates now show their votes from ballots that didn't include any of these winners.`;
        } else {
          roundInfo.innerHTML = `<strong>Removing winner's ballots:</strong> All ballots that included ${prevWinnerNamesString} have been removed. The remaining candidates now show their votes from ballots that didn't include ${prevWinnerNamesString}.`;
        }
      }
    } else if (phase === 'add_excess') {
      if (roundIndex > 0) {
        const prevWinners = animationRounds[roundIndex - 1].winners;
        const prevWinnerNames = prevWinners.map(id => candidates[id]);
        const prevWinnerNamesString = prevWinnerNames.length === 1 
          ? prevWinnerNames[0]
          : prevWinnerNames.length === 2 
            ? `${prevWinnerNames[0]} and ${prevWinnerNames[1]}`
            : prevWinnerNames.slice(0, -1).join(', ') + ', and ' + prevWinnerNames[prevWinnerNames.length - 1];
        
        // Calculate the excess for first winner (all tied winners have same excess)
        const prevWinner = prevWinners[0];
        let originalWinnerVotes = 0;
        if (animationRounds[roundIndex - 1].votes_per_candidate && animationRounds[roundIndex - 1].votes_per_candidate[prevWinner]) {
          originalWinnerVotes = animationRounds[roundIndex - 1].votes_per_candidate[prevWinner].length;
        }
        const threshold = winnerThresholds[prevWinner];
        const excess = originalWinnerVotes - threshold;
        
        if (prevWinners.length > 1) {
          const totalExcess = excess * prevWinners.length;
          roundInfo.innerHTML = `<strong>Adding excess votes:</strong> The ${totalExcess.toFixed(1)} total excess votes (${excess.toFixed(1)} from each winner) from ${prevWinnerNamesString} are being redistributed to the remaining candidates based on which other candidates those supporters voted for.`;
        } else {
          roundInfo.innerHTML = `<strong>Adding excess votes:</strong> The ${excess.toFixed(1)} excess votes from ${prevWinnerNamesString} are being redistributed to the remaining candidates based on which other candidates ${prevWinnerNamesString}'s supporters voted for.`;
        }
      } else {
        roundInfo.innerHTML = `<strong>All seats filled!</strong> The election is complete with ${seats} winner${seats > 1 ? 's' : ''}.`;
      }
    }
  }
  
  // Animation functions
  function nextStep() {
    if (currentPhase === 'initial') {
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    } else if (currentPhase === 'winner') {
      if (currentRound < animationRounds.length - 1) {
        // Move to remove_excess phase (stay on same round)
        currentPhase = 'remove_excess';
        updateChart(currentRound, 'remove_excess');
      } else {
        // Animation complete - stop and schedule reset
        stopAnimation();
        setTimeout(() => {
          resetAnimation();
        }, 3000); // Wait 3 seconds before resetting
      }
    } else if (currentPhase === 'remove_excess') {
      // Now move to next round for remove_ballots
      currentRound++;
      currentPhase = 'remove_ballots';
      updateChart(currentRound, 'remove_ballots');
    } else if (currentPhase === 'remove_ballots') {
      currentPhase = 'add_excess';
      updateChart(currentRound, 'add_excess');
    } else if (currentPhase === 'add_excess') {
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    }
  }
  
  function prevStep() {
    if (currentPhase === 'initial' && currentRound > 0) {
      currentPhase = 'add_excess';
      updateChart(currentRound, 'add_excess');
    } else if (currentPhase === 'add_excess') {
      currentPhase = 'remove_ballots';
      updateChart(currentRound, 'remove_ballots');
    } else if (currentPhase === 'remove_ballots') {
      currentPhase = 'remove_excess';
      updateChart(currentRound, 'remove_excess');
    } else if (currentPhase === 'remove_excess') {
      currentRound--;
      currentPhase = 'winner';
      updateChart(currentRound, 'winner');
    } else if (currentPhase === 'winner') {
      currentPhase = 'initial';
      updateChart(currentRound, 'initial');
    }
  }
  
  function playAnimation() {
    isPlaying = true;
    document.getElementById('playBtn').textContent = 'Pause';
    animationTimer = setInterval(() => {
      nextStep();
      // Check if we've reached the end
      if (currentRound >= animationRounds.length - 1 && currentPhase === 'winner') {
        // Will auto-reset after showing final state
        return;
      }
    }, 3000); // 3 seconds per step to allow time to read captions
  }
  
  function stopAnimation() {
    isPlaying = false;
    document.getElementById('playBtn').textContent = 'Play Animation';
    if (animationTimer) {
      clearInterval(animationTimer);
      animationTimer = null;
    }
  }
  
  function resetAnimation() {
    stopAnimation();
    currentRound = 0;
    currentPhase = 'initial';
    // Clear stored winner thresholds
    for (let key in winnerThresholds) {
      delete winnerThresholds[key];
    }
    updateChart(0, 'initial');
  }
  
  // Event listeners
  document.getElementById('playBtn').addEventListener('click', () => {
    if (isPlaying) {
      stopAnimation();
    } else {
      playAnimation();
    }
  });
  
  document.getElementById('resetBtn').addEventListener('click', resetAnimation);
  document.getElementById('nextBtn').addEventListener('click', () => {
    stopAnimation();
    nextStep();
  });
  document.getElementById('prevBtn').addEventListener('click', () => {
    stopAnimation();
    prevStep();
  });
  
  // Initialize with first round
  updateChart(0, 'initial');
  
  // Set container height
  d3.select("#chart")
    .style("height", totalHeight + "px")
    .style("margin-bottom", "2rem");
</script>
{% endif %}
{% endblock %}